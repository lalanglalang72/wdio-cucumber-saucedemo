{"info":{"type":"runner","start":"2024-07-07T07:02:44.445Z","end":"2024-07-07T07:02:50.123Z","_duration":5678,"cid":"1-1","capabilities":{"acceptInsecureCerts":true,"browserName":"MicrosoftEdge","browserVersion":"126.0.2592.87","fedcm:accounts":true,"ms:edgeOptions":{"debuggerAddress":"localhost:51854"},"msedge":{"msedgedriverVersion":"126.0.2592.87 (883b9421f9ba9ce195934ad8d16cb5215b659245)","userDataDir":"C:\\Users\\Joshua\\AppData\\Local\\Temp\\scoped_dir26364_198296429"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:extension:minPinLength":true,"webauthn:extension:prf":true,"webauthn:virtualAuthenticators":true,"wdio:driverPID":26364,"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41"},"sanitizedCapabilities":"microsoftedge.126_0_2592_87.windows","config":{"protocol":"http","hostname":"0.0.0.0","path":"/","capabilities":{"browserName":"MicrosoftEdge","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"cacheDir":"C:\\Users\\Joshua\\AppData\\Local\\Temp","port":51836,"requestedCapabilities":{"browserName":"MicrosoftEdge","acceptInsecureCerts":true},"automationProtocol":"webdriver","waitforInterval":500,"waitforTimeout":10000,"onReload":[],"beforeCommand":[],"afterCommand":[],"rootDir":"D:\\Project\\wdio-cucumber-ds-b4","specs":["./features/**/*.feature"],"suites":{},"exclude":[],"groupLogsByTestSpec":false,"excludeDriverLogs":[],"bail":0,"framework":"cucumber","reporters":["spec","cucumberjs-json",["html-nice",{"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":[],"maxInstances":5,"maxInstancesPerCapability":100,"injectGlobals":true,"filesToWatch":[],"execArgv":[],"runnerEnv":{},"runner":"local","shard":{"current":1,"total":1},"specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true},"babelOpts":{}},"mochaOpts":{"timeout":10000},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":60000,"require":["./features/step-definitions/steps.js"],"backtrace":false,"requireModule":[],"dryRun":false,"failFast":false,"name":[],"snippets":true,"source":true,"strict":false,"tagExpression":"","ignoreUndefinedDefinitions":false},"onPrepare":[],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[null],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[null],"onComplete":[],"beforeAssertion":[],"afterAssertion":[],"beforeFeature":[null],"beforeScenario":[null],"beforeStep":[null],"afterStep":[null],"afterScenario":[],"afterFeature":[],"_":["run","run"],"$0":"node_modules\\@wdio\\cli\\bin\\wdio.js","config-path":"wdio.conf.js","ignoredWorkerServices":[]},"specs":["file:///D:/Project/wdio-cucumber-ds-b4/features/login-positive.feature"],"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","isMultiremote":false,"instanceOptions":{"19f9d7c392635eea7e5f7f0d3bb2ab41":{"protocol":"http","hostname":"0.0.0.0","path":"/","capabilities":{"browserName":"MicrosoftEdge","acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"cacheDir":"C:\\Users\\Joshua\\AppData\\Local\\Temp","port":51836,"requestedCapabilities":{"browserName":"MicrosoftEdge","acceptInsecureCerts":true},"automationProtocol":"webdriver","waitforInterval":500,"waitforTimeout":10000,"onReload":[],"beforeCommand":[],"afterCommand":[],"rootDir":"D:\\Project\\wdio-cucumber-ds-b4","specs":["./features/**/*.feature"],"suites":{},"exclude":[],"groupLogsByTestSpec":false,"excludeDriverLogs":[],"bail":0,"framework":"cucumber","reporters":["spec","cucumberjs-json",["html-nice",{"outputDir":"./reports/html-reports/","filename":"report.html","reportTitle":"Test Report Title","linkScreenshots":true,"showInBrowser":true,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":[],"maxInstances":5,"maxInstancesPerCapability":100,"injectGlobals":true,"filesToWatch":[],"execArgv":[],"runnerEnv":{},"runner":"local","shard":{"current":1,"total":1},"specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true},"babelOpts":{}},"mochaOpts":{"timeout":10000},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":60000,"require":["./features/step-definitions/steps.js"],"backtrace":false,"requireModule":[],"dryRun":false,"failFast":false,"name":[],"snippets":true,"source":true,"strict":false,"tagExpression":"","ignoreUndefinedDefinitions":false},"onPrepare":[],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[null],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[null],"onComplete":[],"beforeAssertion":[],"afterAssertion":[],"beforeFeature":[null],"beforeScenario":[null],"beforeStep":[null],"afterStep":[null],"afterScenario":[],"afterFeature":[],"_":["run","run"],"$0":"node_modules\\@wdio\\cli\\bin\\wdio.js","config-path":"wdio.conf.js","ignoredWorkerServices":[]}},"retry":0,"failures":0,"retries":0},"metrics":{"passed":10,"skipped":0,"failed":0,"duration":5678,"start":"2024-07-07T07:02:44.447Z","end":"2024-07-07T07:02:50Z"},"title":"Test Report Title","suites":[{"type":"feature","start":"2024-07-07T07:02:44.540Z","end":"2024-07-07T07:02:50.028Z","_duration":5487,"uid":"login-positive.feature:2:1","cid":"1-1","file":"D:\\Project\\wdio-cucumber-ds-b4\\features\\login-positive.feature","title":"Saucedemo Positive Login","tags":[{"location":{"line":1,"column":1},"name":"@saucedemo","id":"0da957dc-32cd-4d22-8ac4-0db1d42ea23c"},{"location":{"line":1,"column":12},"name":"@login","id":"7f1aa247-1805-4c8b-9f88-d4793ba4f458"},{"location":{"line":1,"column":19},"name":"@positive","id":"cc71566e-c94c-42c2-a90f-1a64220ae2a8"}],"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2024-07-07T07:02:44.572Z","end":"2024-07-07T07:02:49.337Z","_duration":4764,"uid":"0","cid":"1-1","file":"D:\\Project\\wdio-cucumber-ds-b4\\features\\login-positive.feature","title":"Successful Login","fullTitle":"login-positive.feature:2:1: Successful Login","tags":[{"name":"@saucedemo","astNodeId":"0da957dc-32cd-4d22-8ac4-0db1d42ea23c"},{"name":"@login","astNodeId":"7f1aa247-1805-4c8b-9f88-d4793ba4f458"},{"name":"@positive","astNodeId":"cc71566e-c94c-42c2-a90f-1a64220ae2a8"},{"name":"@positive-tc","astNodeId":"09b9f44b-c2be-4f2b-a4e8-c5bdefe0639f"}],"tests":[{"type":"test","start":"2024-07-07T07:02:44.579Z","end":"2024-07-07T07:02:48.837Z","_duration":4258,"uid":"a4aae551-ca1b-45d1-972a-af697cbb1b39","cid":"1-1","title":"Given user is on Saucedemo Login Page","fullTitle":"0: Given user is on Saucedemo Login Page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:48.838Z","end":"2024-07-07T07:02:48.968Z","_duration":130,"uid":"268527f6-2a57-49c0-a8c9-f05ba24ce735","cid":"1-1","title":"And user input username with \"standard_user\"","fullTitle":"0: And user input username with \"standard_user\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/value","body":{"text":"standard_user"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:48.968Z","end":"2024-07-07T07:02:49.143Z","_duration":175,"uid":"e49ed0db-50c6-4371-a7da-e41015612c0f","cid":"1-1","title":"And user input password with \"secret_sauce\"","fullTitle":"0: And user input password with \"secret_sauce\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/value","body":{"text":"secret_sauce"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.145Z","end":"2024-07-07T07:02:49.295Z","_duration":150,"uid":"5a622099-ce8a-4696-a584-439934b8d57e","cid":"1-1","title":"When user click login button","fullTitle":"0: When user click login button","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.5"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.5/click","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.5/click","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.295Z","end":"2024-07-07T07:02:49.334Z","_duration":39,"uid":"a89db76f-a080-46bc-b500-26233fdda46b","cid":"1-1","title":"Then user should redirect to the homepage","fullTitle":"0: Then user should redirect to the homepage","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14"}]},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14"}]},"result":{"value":true},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-07-07T07:02:44.575Z","end":"2024-07-07T07:02:44.578Z","_duration":3,"uid":"7f53ad27-7a4f-424f-a057-e351a516fd3d","cid":"1-1","title":"","parent":"0","errors":[]},{"type":"hook","start":"2024-07-07T07:02:49.335Z","end":"2024-07-07T07:02:49.335Z","_duration":0,"uid":"b6be5563-ff61-458f-863d-3608d5f4056f","cid":"1-1","title":"","parent":"0","errors":[]}],"suites":[],"parent":"login-positive.feature:2:1","hooksAndTests":[{"type":"hook","start":"2024-07-07T07:02:44.575Z","end":"2024-07-07T07:02:44.578Z","_duration":3,"uid":"7f53ad27-7a4f-424f-a057-e351a516fd3d","cid":"1-1","title":"","parent":"0","errors":[]},{"type":"test","start":"2024-07-07T07:02:44.579Z","end":"2024-07-07T07:02:48.837Z","_duration":4258,"uid":"a4aae551-ca1b-45d1-972a-af697cbb1b39","cid":"1-1","title":"Given user is on Saucedemo Login Page","fullTitle":"0: Given user is on Saucedemo Login Page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:48.838Z","end":"2024-07-07T07:02:48.968Z","_duration":130,"uid":"268527f6-2a57-49c0-a8c9-f05ba24ce735","cid":"1-1","title":"And user input username with \"standard_user\"","fullTitle":"0: And user input username with \"standard_user\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/value","body":{"text":"standard_user"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.3/value","body":{"text":"standard_user"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:48.968Z","end":"2024-07-07T07:02:49.143Z","_duration":175,"uid":"e49ed0db-50c6-4371-a7da-e41015612c0f","cid":"1-1","title":"And user input password with \"secret_sauce\"","fullTitle":"0: And user input password with \"secret_sauce\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/value","body":{"text":"secret_sauce"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.4/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.145Z","end":"2024-07-07T07:02:49.295Z","_duration":150,"uid":"5a622099-ce8a-4696-a584-439934b8d57e","cid":"1-1","title":"When user click login button","fullTitle":"0: When user click login button","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.5"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.5/click","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.5/click","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.295Z","end":"2024-07-07T07:02:49.334Z","_duration":39,"uid":"a89db76f-a080-46bc-b500-26233fdda46b","cid":"1-1","title":"Then user should redirect to the homepage","fullTitle":"0: Then user should redirect to the homepage","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14"}]},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.C2CD84B3A46A976B214F233F50D1C042.e.14"}]},"result":{"value":true},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-07-07T07:02:49.335Z","end":"2024-07-07T07:02:49.335Z","_duration":0,"uid":"b6be5563-ff61-458f-863d-3608d5f4056f","cid":"1-1","title":"","parent":"0","errors":[]}],"description":""},{"type":"scenario","start":"2024-07-07T07:02:49.337Z","end":"2024-07-07T07:02:50.027Z","_duration":689,"uid":"1","cid":"1-1","file":"D:\\Project\\wdio-cucumber-ds-b4\\features\\login-positive.feature","title":"Successful Login","fullTitle":"login-positive.feature:2:1: Successful Login","tags":[{"name":"@saucedemo","astNodeId":"0da957dc-32cd-4d22-8ac4-0db1d42ea23c"},{"name":"@login","astNodeId":"7f1aa247-1805-4c8b-9f88-d4793ba4f458"},{"name":"@positive","astNodeId":"cc71566e-c94c-42c2-a90f-1a64220ae2a8"},{"name":"@positive-tc","astNodeId":"09b9f44b-c2be-4f2b-a4e8-c5bdefe0639f"}],"tests":[{"type":"test","start":"2024-07-07T07:02:49.338Z","end":"2024-07-07T07:02:49.803Z","_duration":465,"uid":"45c5a1e7-9186-45e3-b9d5-81018bb0b8f8","cid":"1-1","title":"Given user is on Saucedemo Login Page","fullTitle":"1: Given user is on Saucedemo Login Page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.804Z","end":"2024-07-07T07:02:49.886Z","_duration":82,"uid":"75ee33a2-660b-425a-b40a-44a25146ce6a","cid":"1-1","title":"And user input username with \"visual_user\"","fullTitle":"1: And user input username with \"visual_user\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/value","body":{"text":"visual_user"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/value","body":{"text":"visual_user"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.886Z","end":"2024-07-07T07:02:49.955Z","_duration":69,"uid":"3b3e2f06-0f10-475e-b4a1-0a87f8c554be","cid":"1-1","title":"And user input password with \"secret_sauce\"","fullTitle":"1: And user input password with \"secret_sauce\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/value","body":{"text":"secret_sauce"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.955Z","end":"2024-07-07T07:02:50.006Z","_duration":51,"uid":"062aaf52-a1cc-4d7d-9033-9f69fb079334","cid":"1-1","title":"When user click login button","fullTitle":"1: When user click login button","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.27"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.27/click","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.27/click","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:50.006Z","end":"2024-07-07T07:02:50.026Z","_duration":20,"uid":"6867207d-f61b-4161-b8bf-c1507b483986","cid":"1-1","title":"Then user should redirect to the homepage","fullTitle":"1: Then user should redirect to the homepage","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40"}]},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40"}]},"result":{"value":true},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-07-07T07:02:49.337Z","end":"2024-07-07T07:02:49.338Z","_duration":1,"uid":"6ab526bc-9b99-4a4e-bbf7-4f26fa7af8b4","cid":"1-1","title":"","parent":"1","errors":[]},{"type":"hook","start":"2024-07-07T07:02:50.026Z","end":"2024-07-07T07:02:50.026Z","_duration":0,"uid":"0004b03d-d7ea-4192-8f48-a502bcfedf10","cid":"1-1","title":"","parent":"1","errors":[]}],"suites":[],"parent":"login-positive.feature:2:1","hooksAndTests":[{"type":"hook","start":"2024-07-07T07:02:49.337Z","end":"2024-07-07T07:02:49.338Z","_duration":1,"uid":"6ab526bc-9b99-4a4e-bbf7-4f26fa7af8b4","cid":"1-1","title":"","parent":"1","errors":[]},{"type":"test","start":"2024-07-07T07:02:49.338Z","end":"2024-07-07T07:02:49.803Z","_duration":465,"uid":"45c5a1e7-9186-45e3-b9d5-81018bb0b8f8","cid":"1-1","title":"Given user is on Saucedemo Login Page","fullTitle":"1: Given user is on Saucedemo Login Page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.804Z","end":"2024-07-07T07:02:49.886Z","_duration":82,"uid":"75ee33a2-660b-425a-b40a-44a25146ce6a","cid":"1-1","title":"And user input username with \"visual_user\"","fullTitle":"1: And user input username with \"visual_user\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#user-name"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/value","body":{"text":"visual_user"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.25/value","body":{"text":"visual_user"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.886Z","end":"2024-07-07T07:02:49.955Z","_duration":69,"uid":"3b3e2f06-0f10-475e-b4a1-0a87f8c554be","cid":"1-1","title":"And user input password with \"secret_sauce\"","fullTitle":"1: And user input password with \"secret_sauce\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#password"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/clear","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/clear","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/value","body":{"text":"secret_sauce"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.26/value","body":{"text":"secret_sauce"},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:49.955Z","end":"2024-07-07T07:02:50.006Z","_duration":51,"uid":"062aaf52-a1cc-4d7d-9033-9f69fb079334","cid":"1-1","title":"When user click login button","fullTitle":"1: When user click login button","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#login-button"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.27"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.27/click","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.27/click","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-07T07:02:50.006Z","end":"2024-07-07T07:02:50.026Z","_duration":20,"uid":"6867207d-f61b-4161-b8bf-c1507b483986","cid":"1-1","title":"Then user should redirect to the homepage","fullTitle":"1: Then user should redirect to the homepage","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"#shopping_cart_container"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40"}},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40"}]},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40","ELEMENT":"f.A22C76A34CD0561887FA99C816243F0F.d.F168FAD162948E6D3A10028EBCD06638.e.40"}]},"result":{"value":true},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"19f9d7c392635eea7e5f7f0d3bb2ab41","cid":"1-1","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-07-07T07:02:50.026Z","end":"2024-07-07T07:02:50.026Z","_duration":0,"uid":"0004b03d-d7ea-4192-8f48-a502bcfedf10","cid":"1-1","title":"","parent":"1","errors":[]}],"description":""}],"hooksAndTests":[],"description":""}],"reportFile":"D:\\Project\\wdio-cucumber-ds-b4\\reports\\html-reports\\report-1-1.html","browserName":"not specified"}